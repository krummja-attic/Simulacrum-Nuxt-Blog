---
title: refactor/components
description: Reworking some of the component logic and entity event processing.
project: Anathema
repo: https://github.com/krummja/Anathema
---

## Problem

Anathema's interaction system makes heavy use of the `EntityEvent` class provided by [ECStremity](https://github.com/krummja/ECStremity). This works very well, but I have to do a couple of "hacky" things to route data from the player's `Actor` component to the target interactable entity to the interface and systems logic.

Currently I pass a `dict` along as event data, usually with some field that contains an iterable I can collect usable information in. This can be a bit messy, especially when it comes to getting information to the UI, so I want to address that if I can.

In this devlog, I want to write out some notes outlining how this works, ultimately aiming to tighten up the process to make it more reliable and easier to use.

## Example Case

Let's take a look at an example of a basic interaction, say a player movement that touches some entity in the world that, on touch, triggers a state change in the entity. A prime example is a chest or other container, which we expect to (a) change visual state, and (b) raise a modal in the UI with options to select from. On selection of an option, some method on the entity's components should be fired, resulting in a change to the game state.

### Player Movement

Inputs are handled by a manager class, `Anathema.core.input.InputController`, which essentially wraps `bearlibterminal`'s `terminal.read` to get key events.

#### InputController

```python
def handle_input(self) -> Optional[Callable[[], None]]:
    terminal: NiceTerminal = self.game.renderer.terminal
    key: int = terminal.read()

    try:
        command: Callable[[], None] = self.command_lookup(key)
    except StateBreak:
        return None
    if command is not None:
        return command
```

On each input event, the `key` is passed to a method `command_lookup` on the `InputController` and ultimately to a separate `CommandLibrary`.

```python
def command_lookup(self, key: int) -> Optional[Callable[[], None]]:
    if key in CommandLibrary.MOVE_KEYS:
        return self._current_screen.cmd_move(*CommandLibrary.MOVE_KEYS[key])
    if key in CommandLibrary.COMMAND_KEYS[self._current_screen.name]:
        commands = CommandLibrary.COMMAND_KEYS[self._current_screen.name]
        return getattr(self._current_screen, f"cmd_{commands[key]}")
    elif key in CommandLibrary.COMMAND_KEYS['DEFAULT']:
        commands = CommandLibrary.COMMAND_KEYS['DEFAULT]
        return getattr(self._current_screen, f"cmd_{commands[key]}")
    else:
        return None
```
<sticky style="font-size: 14pt;">One minor annoyance I should look into fixing is that I have to override the cmd_* methods in any Screen subclasses I don't want that behavior to be present in...</sticky>

In short, a keyboard input is an `int` that is checked against a dictionary of pre-defined methods on `Screen` objects. These methods are all prefixed `cmd_*`, making lookup and, ultimately, calling of the relevant methods fairly straightforward.[^1]

Of interest to the current use case is moving the player. So, we press an arrow key (or numpad key) on the keyboard, which returns something we can check against our `CommandLibrary`.

```python
MOVE_KEYS: Dict[int, Tuple[int, int]] = {
    # ...
    blt.TK_UP: (0, -1),
    # ...
    blt.TK_KP_8: (0, -1),
    # ...
    }
```

In our `InputController`, we're passing the dictionary value to `cmd_move` on the currently active `Screen`. During gameplay, this is our `PlayerReady` screen, so let's see what happens there.

#### PlayerReady

It turns out not to be too interesting.

```python
def cmd_move(self, x: int, y: int) -> None:
    self.game.player.move((x, y))
```

Our method simply routes the tuple we got from our `CommandLibrary` to the `move` method on the game's `PlayerManager`, so heading there...

#### PlayerManager

Aha, now we're talking! Now we have to handle some concrete logic. Note firstly that we store the player's position as a property, which is just for convenience.

```python
@property
def position(self) -> Tuple[int, int]:
    return self.entity['Position'].xy
```

We use this property in our `move` method:

```python
def move(self, direction: Tuple[int, int]) -> None:
    target_x = self.position[0] + direction[0]
    target_y = self.position[1] + direction[1]
    # ...
```

We compute a target position by adding our input offset to our current position. If position is `(10, 12)` and we returned the value of `blt.TK_UP`, then we'll get an updated position `(10, 11)`. Simple!

Now, in a completely featureless environment where we don't care about collisions or other entities, we simply pass this new position to an `Action` which we enqueue to be executed on the next turn.

```python
    # ...
    self.action_queue.append(
        Action( entity = self.entity,
                event  = 'try_move',
                data   = {'target': (target_x, target_y)} ))
```

The `PlayerManager` has an `action_queue` attribute which is a `collections.deque` instance. Each cycle of the game engine, if this queue has anything in it, we call a method `get_next_action` which in turn calls `self.action_queue.popleft()`. We return this to the `ActionSystem` which calls `Action.act`. So let's see how that works before proceeding with the remaining logic here in our `move` method.

#### Action and ActionSystem

When we enqueued our `Action`, we passed in a bunch of information that we'll need for resolving the actual action logic.

```python
@dataclass
class Action:
    entity: Entity
    event: str
    data: Dict[str, Any]
```

In the `ActionSystem`, we call the `Action.act` method to execute the actual logic of the action.

```python
class ActionSystem(AbstractSystem):
    #...
    def update(self) -> bool:
        entities = self._query.result
        entities = deque(sorted(entities, key=lambda e: e['Actor']))
        entity = entities.popleft()
        # ...
        while entity and entity['Actor'].has_energy:
            if entity.has('IsPlayer'):
                try:
                    action = self.game.player.get_next_action()
                    if action:
                        action.act()
                        return True
                    continue
                except IndexError:
                    return False
        #...
```

The `_query` attribute holds references to all of the entities in the game that have an `Actor` component.[^2] We sort our entities by their `Actor` component (which sorts them by energy - more on that later). If the current entity is the player, get the next player action and run its `act` method - so let's look at what that entails.

```python
    # in Action
    def act(self) -> None:
        return self.entity.fire_event(self.event, self.data)
```

Alright, so that's straightforward. We're using the ECS to make an `EntityEvent`, passing in our event data that we set up in the `PlayerManager`:

```python
    def act(self) -> None:
        return self.entity.fire_event('try_move',
                                      {'target': (target_x, target_y)})
```

The `fire_event` method broadcasts the event `try_move` with data `{'target': (..., ...)}` to every component attached to the player entity. To be usable, at least one component better implement a method `on_try_move` for the ECS to do something with. Well, it so happens that our player does have such a component:

```python
class Legs(BodyPart):
    #...
    def on_try_move(self, evt: EntityEvent) -> None:
        self.update_position(*evt.data['target'])
        evt.handle()

    def update_position(self, x: int, y: int) -> None:
        self.entity['Position'].x = x
        self.entity['Position'].y = y
```

The end result is that the actual position of the entity changes on the next cycle of the `PhysicsSystem`, which queries for entities with `Position` and updates them accordingly.

### Comments

Alright, so that was a lot to unpack. The basic workflow, however, is fairly straightforward.

1. Get input from the keyboard.
2. Look up an appropriate method or tuple.
3. Fire the method on the current Screen or pass a tuple to a method.
4. Create an `Action` with, at minimum, an event name (a string) and some concrete data (a dict).
5. Enqueue the action.
6. Fire the action's event, broadcasting it to the entity's component set.
7. On detecting an event, grab the event data and do some work with it.

Now, this is the simplest case. However, there is more that happens in the `PlayerManager`. Recall that we just created an action without regard for other world entities. What if we want to check for obstacles, or do something like see if we're running into an interactable? Well... then things get just a tad more complex.

[^1]: This is a pattern that I first came across while studying [HexDecimal's tcod-based tutorial project](https://github.com/HexDecimal/roguelike-tutorial). I've since implemented it in most of my projects, as it's so intuitive.

[^2]: See the documentation for [ECStremity](https://github.com/krummja/ECStremity) to see how this works in more detail.
