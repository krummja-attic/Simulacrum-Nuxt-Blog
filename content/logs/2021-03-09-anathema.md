---
title: refactor/components
description: Part 2 of component logic rework.
project: Anathema
repo: https://github.com/krummja/Anathema
---

This is continued from [Part 1](https://www.simulacrum.space/devlog/2021-03-07-anathema).

## Advanced Case

Recall that the `PlayerManager` is where we routed our position offset via `cmd_move` on the active Screen. We calculated the new position, then created an `Action` instance with that target position as data, with an event `'try_move'` to fire on the player's entity. To account for collisions, we need to intervene in the `PlayerManager` and check the target position for entities with a `Blocker` component.

```python
    # ...
    def move(self, direction: Tuple[int, int]) -> None:
        target_x = self.position[0] + direction[0]
        target_y = self.position[1] + direction[1]

        if self.game.world.current_area.is_blocked(target_x, target_y):
            # ...
    # ...
```

### Area and PhysicsSystem

Over in the `Area` class, we want to route our target coordinates over to the game's `PhysicsSystem`, where we'll query the ECS for `Blockers`:

```python
class Area:
    # ...
    def is_blocked(self, x: int, y: int) -> bool:
        #...
        if not self.region.world.game.physics_system.passable[x][y]:
            return True
        else:
            return False
```

The `PhysicsSystem` maintains a boolean array that stores all of our passable coordinates. It updates this array on each engine cycle by querying for entities with a `Blocker` component. For each of those entities, it sets that entity's position to impassable, and then updates the array for passable positions (necessary to actually update the array data).

```python
class PhysicsSystem(AbstractSystem):

    def __init__(self, game: Game) -> None:
        # ...
        self._blockers = self.ecs.create_query(all_of=[ 'Blocker' ])
        # ...
        self.passable = np.ones((64, 64), dtype=np.bool, order="F")

    # ...
    def update(self, dt) -> None:
        for target in self._blockers.result:
            x, y = target['Position']
            if target.has('Blocker'):
                self.passable[x][y] = False
            else:
                self.passable[x][y] = True
```

With this data, we can now handle the case that the target position is blocked.

```python
    # ...
    def move(self, direction: Tuple[int, int]) -> None:
        target_x = self.position[0] + direction[0]
        target_y = self.position[1] + direction[1]

        if self.game.world.current_area.is_blocked(target_x, target_y):
            self.game.log.report(Message("The way is blocked!"))
        else:
            # Action with event `'try_move'`.
    # ...
```

Alright, now we're cruisin' - at least, where we're supposed to be cruisin'. Now we can actually get to the case that I wanted to evaluate, which is interaction with other entities. For this, we need to do a similar to check to blockers, but instead we want to check for entities with an `IsInteractable` component. To do this, we'll do a second check right after our blocker check, so that if we are blocked, we want to subsequently check if we can interact with the entity blocking our movement.

<sticky>Checking for interactables at the target position, then separately getting the interactable seems like it could be implemented more cleanly...</sticky>

```python
    # ...
    def move(self, direction: Tuple[int, int]) -> None:
        target_x = self.position[0] + direction[0]
        target_y = self.position[1] + direction[1]

        if self.game.world.current_area.is_blocked(target_x, target_y):

            if self.game.world.current_area.is_interactable(target_x, target_y):
                interactable = self.game.interaction_system.get(target_x, target_y)

                self.action_queue.append(
                    Action(entity = self.entity,
                           event  = 'try_get_interactions',
                           data   = {'target': interactable,
                                     'expect': []}))
            else:
                self.game.log.report(Message("The way is blocked!"))
        else:
            # Action with event `'try_move'`.
    # ...
```

When our Action with event `'try_get_interactions'` is run, we want to again have a component on our player entity that has a corresponding method. While `'try_move'` had a natural home in our Legs component, I've shoved our interactions event in the Actor component. I might change this later, but it works on the thinking that the Actor represents the entity's "brain", hence would be responsible for "reasoning out" what is interactable and what to do with it.

### Actor

Unlike the case of `'try_move'` where we just had to run a position update, for interactions we have to do a bit more. Recall that we grabbed a reference to the target interactable, which we now want to make fire an event of its own.

```python
def Action(Component):
    # ...
    def on_try_get_interactions(self, evt: EntityEvent) -> None:
        target = evt.data['target']
        evt = target.fire_event('get_interactions', evt.data)
        interactions = evt.data['expect']
        # ...
```

Let's stop and explore what's happening here. Because ECStremity's event system only fires events to the components on the firing entity, we have to separately pass in a target and "force" it to fire an event of its own to get usable information back from the target's components. We pass the original event's data dict as data for the new event, where we'll want any components on the target to do something with the `'expect'` field. In this case, the field holds a list, so we <i>expect</i> (heh...) any and all components to append data for us to work with.
